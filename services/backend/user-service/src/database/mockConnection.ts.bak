/**
 * Temporary Database Connection for Integration Testing
 * Uses SQLite in-memory database when Docker is not available
 */
import { Pool } from 'pg';
import Database from 'better-sqlite3';

// Mock database for integration testing
class MockDatabase {
  private db: any;
  private users: any[] = [];
  private nextId = 1;

  constructor() {
    console.log('ðŸ”§ Using Mock Database for Integration Testing');
    this.db = new Database(':memory:');
    this.initTables();
  }

  private initTables() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT UNIQUE NOT NULL,
        username TEXT UNIQUE NOT NULL,
        password_hash TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
  }

  async query(text: string, params?: any[]): Promise<any> {
    try {
      if (text.includes('SELECT') && text.includes('users')) {
        if (text.includes('WHERE email = $1')) {
          const user = this.users.find(u => u.email === params?.[0]);
          return { rows: user ? [user] : [] };
        }
        if (text.includes('WHERE id = $1')) {
          const user = this.users.find(u => u.id === parseInt(params?.[0]));
          return { rows: user ? [user] : [] };
        }
        return { rows: this.users };
      }

      if (text.includes('INSERT INTO users')) {
        const [email, username, passwordHash] = params || [];
        const user = {
          id: this.nextId++,
          email,
          username,
          password_hash: passwordHash,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        };
        this.users.push(user);
        return { rows: [user] };
      }

      if (text.includes('UPDATE users')) {
        const userId = params?.[params.length - 1];
        const userIndex = this.users.findIndex(u => u.id === parseInt(userId));
        if (userIndex !== -1) {
          // Simple update logic
          this.users[userIndex].updated_at = new Date().toISOString();
          return { rows: [this.users[userIndex]] };
        }
        return { rows: [] };
      }

      if (text.includes('DELETE FROM users')) {
        const userId = params?.[0];
        const userIndex = this.users.findIndex(u => u.id === parseInt(userId));
        if (userIndex !== -1) {
          this.users.splice(userIndex, 1);
          return { rowCount: 1 };
        }
        return { rowCount: 0 };
      }

      return { rows: [] };
    } catch (error) {
      console.error('Mock database error:', error);
      throw error;
    }
  }

  async end() {
    this.db.close();
  }
}

// Create connection based on environment
export function createConnection() {
  if (process.env.NODE_ENV === 'test' || !process.env.DATABASE_URL || process.env.USE_MOCK_DB === 'true') {
    return new MockDatabase();
  }

  // Try real PostgreSQL connection
  try {
    return new Pool({
      connectionString: process.env.DATABASE_URL || 'postgresql://postgres:password@localhost:5432/fantacontratti_users',
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    });
  } catch (error) {
    console.warn('PostgreSQL connection failed, falling back to mock database');
    return new MockDatabase();
  }
}

export default createConnection;